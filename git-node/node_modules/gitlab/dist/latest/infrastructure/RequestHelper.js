"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _humps = _interopRequireDefault(require("humps"));

var _parseLinkHeader = _interopRequireDefault(require("parse-link-header"));

var _qs = _interopRequireDefault(require("qs"));

var _urlJoin = _interopRequireDefault(require("url-join"));

var _request = _interopRequireDefault(require("request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function defaultRequest({
  url,
  useXMLHttpRequest
}, endpoint, {
  headers,
  body,
  qs,
  formData,
  resolveWithFullResponse = false
}) {
  const params = {
    url: (0, _urlJoin.default)(url, endpoint),
    headers,
    json: true
  };
  if (body) params.body = _humps.default.decamelizeKeys(body);

  if (qs) {
    if (useXMLHttpRequest) {
      // The xhr package doesn't have a way of passing in a qs object until v3
      params.url = (0, _urlJoin.default)(params.url, `?${_qs.default.stringify(_humps.default.decamelizeKeys(qs))}`);
    } else {
      params.qs = _humps.default.decamelizeKeys(qs);
    }
  }

  if (formData) params.formData = formData;
  params.resolveWithFullResponse = resolveWithFullResponse;
  return params;
}

function getStream(service, endpoint, options = {}) {
  if (service.useXMLHttpRequest) {
    throw new Error('Cannot use streaming functionality with XMLHttpRequest. Please instantiate without this option to use streaming');
  }

  const requestOptions = defaultRequest(service, endpoint, {
    headers: service.headers,
    qs: options
  });
  return _request.default.get(requestOptions);
}

async function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function getPaginated(service, endpoint, options = {}, sleepOnRateLimit = true) {
  const {
    showPagination,
    maxPages
  } = options,
        queryOptions = _objectWithoutProperties(options, ["showPagination", "maxPages"]);

  const requestOptions = defaultRequest(service, endpoint, {
    headers: service.headers,
    qs: queryOptions,
    resolveWithFullResponse: true
  });

  try {
    const response = await service.requester.get(requestOptions);
    const links = (0, _parseLinkHeader.default)(response.headers.link) || {};
    const page = response.headers['x-page'];
    const underMaxPageLimit = maxPages ? page < maxPages : true;
    let more = [];
    let data; // If not looking for a singular page and still under the max pages limit
    // AND their is a next page, paginate

    if (!queryOptions.page && underMaxPageLimit && links.next) {
      more = await getPaginated(service, links.next.url.replace(service.url, ''), options);
      data = [...response.body, ...more];
    } else {
      data = response.body;
    }

    if (queryOptions.page && showPagination) {
      return {
        data,
        pagination: {
          total: response.headers['x-total'],
          next: response.headers['x-next-page'] || null,
          current: response.headers['x-page'] || null,
          previous: response.headers['x-prev-page'] || null,
          perPage: response.headers['x-per-page'],
          totalPages: response.headers['x-total-pages']
        }
      };
    }

    return data;
  } catch (err) {
    const sleepTime = parseInt(err.response.headers['retry-after'], 10);

    if (sleepOnRateLimit && parseInt(err.statusCode, 10) === 429 && sleepTime) {
      await wait(sleepTime * 1000);
      return getPaginated(service, endpoint, options, sleepOnRateLimit);
    }

    throw err;
  }
}

class RequestHelper {
  static async get(service, endpoint, options = {}, {
    stream = false
  } = {}) {
    if (stream) return getStream(service, endpoint, options);
    return getPaginated(service, endpoint, options);
  }

  static post(service, endpoint, options = {}, form = false) {
    const body = form ? 'formData' : 'body';
    const requestOptions = defaultRequest(service, endpoint, {
      headers: service.headers,
      [body]: options
    });
    return service.requester.post(requestOptions);
  }

  static put(service, endpoint, options = {}) {
    const requestOptions = defaultRequest(service, endpoint, {
      headers: service.headers,
      body: options
    });
    return service.requester.put(requestOptions);
  }

  static delete(service, endpoint, options = {}) {
    const requestOptions = defaultRequest(service, endpoint, {
      headers: service.headers,
      qs: options
    });
    return service.requester.delete(requestOptions);
  }

}

var _default = RequestHelper;
exports.default = _default;